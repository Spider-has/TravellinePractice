Models
1. Booking с 14 строчки
  Добавил конструктор, это лучше, чем вызывать инициализатор каждый раз, так как теперь 
  при создании экземпляра мы обязаны передать в конструктор все поля (можно было ещё указать required у полей класса,
  но мне конструктор показался более правильным решением)

  Добавил приватные методы для проверки даты начальной и конечной, потому что наша бизнес-сущность может перекочевать в другие
  сервисы, и если там разработчик забудет явно проверить входящие данные в другом сервисе, то в сущность они запишуться неверно, а проверки
  внутри конструктора не позволят неверным данным записаться в нашу бд, например

  По идее так же можно добавить проверку на корректный currency? или настролько упарываться смысла нет?

2. RoomCategory с 9 строчки
  Добавил конструктор

3. User с 8 строчки
  Добавил конструктор 

BookingService
  0. Инициализация c 9 строчки.
     Вызываю конструкторы для _users и _categories вместо инициализаторов по той же причине, по которой делаю это для Booking
  1. метод Book 
	      54 строчка. Создаю booking через конструктор
  2. метод CancelBooking
        72 строчка. Проверяю не чистые полные Datetime объекты, чтобы сравнивать именно даты бронирования, и не учитывать часы, 
        секунды, минуты
        81 строчка. На всякий случай добавил проверку на категорию (она вряд ли когда-то станет null, но сам факт, что функция может
        вернуть null вместо объекта, меня напрягает) 
  3. метод SearchBookings
        105 строка. В задании сказано, что при фильтрации дата учитывается включительно
  4. метод CalculateCancellationPenaltyAmount  
  	    118 строка. Добавил проверку именно по дате, без учета часов, минут, секунд...
        Правильно ли в рамках этого метода вообще сравнивать даты, суть метода же в другом?
        125 строка. Пофиксил вычисление разницы, теперь, если startDate на 1 день больше datenow, всё высчитывается корректно
        125 строка. Поменял местами startDate и datenow, в задании сказано, что штраф -- положительное число
  5. метод GetCurrencyRate
        135 строка. Вместо умножения делю currencyRate на курс валюты относительно рубля.
  6. метод CalculateBookingCost
        149 строка. Поправил высчитывание totalCost. Сначала получаем разность - затем переводим в нужную валюту
  7. метод CalculateDiscount
        Есть вопрос. Правильно ли я понял, что по задумке скидка должна быть индивидуальной для каждого пользователя и хранится где-то
        в отдельном хранилище. А в этом методе по-хорошему мы должны высчитывать эту самую скидку для каждого пользователя отдельно? 
        Но тут стоит временная заглушка с фиксированной скидкой. 
        Спрашиваю, потому что тогда передача в метод userId имеет смысл, если нет, то мне нужно будет убрать этот параметр.
DTO
  1. Booking DTO. c 13 строки.
    Добавил конструктор по аналогии. Пока писал код, задался вопросом, на чьей стороне лучше делать валидацию входящих данных, по итогу решил
    оставить валидацию на стороне accommondationsProcessor. Так как, если нам понадобится добавить ещё один способ создания BookingDTO, 
    там могут потребоваться другие проверки валидации, а если все уже будет захардкожено в конструкторе, придется писать костыли. 
    Это правильное решение?

Commands
  1. FindBookingByIdCommand
     Пофиксил вывод имени категории команаты. строка 10 (просто обращаюсь к RoomCategory.Name)

AccommondationsProcessor
  1. Book
     54 строка. Добавил проверки валидации на userId, startDate, endDate, currency
     77 строка. Вызываю конструктор bookingDTO вместо инициализатора
  2. Undo
     103 строка. Теперь нельзя отменить действие, если оно не найдено в _executedCommands
  3. Cancel и Find 
      91 строка. Добавил проверку на корректный guid
      122 строка. Добавил проверку на корректный guid
  4. Search
      138 строка. Добавил проверки на корректный формат ввода даты
   

Ссылка на описание этапов фильтрации: https://docs.google.com/document/d/1CaGy1u1ClHRfvRJvtYu15IRjMhuYXNY3gBKXrvmWmyw/edit?usp=sharing